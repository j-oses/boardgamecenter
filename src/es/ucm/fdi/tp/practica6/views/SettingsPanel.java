package es.ucm.fdi.tp.practica6.views;

import es.ucm.fdi.tp.practica6.views.SwingView.PlayerMode;

import javax.swing.*;
import javax.swing.GroupLayout.Alignment;
import javax.swing.border.LineBorder;
import javax.swing.border.TitledBorder;
import javax.swing.table.DefaultTableModel;
import javax.swing.text.DefaultCaret;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.util.ArrayList;

/**
 * The settingsPanel contains all the settings for a game.
 * 
 * @author Jorge
 *
 */
public class SettingsPanel extends JPanel {
	// fix the blank line at the bottom of the statuspanel pls
	private static final long serialVersionUID = 1L;

	/**
	 * The listener for all the events generated in this panel. Each component
	 * action points the corresponding method in this interface.
	 * 
	 * @author Jorge
	 *
	 */
	public interface SettingsListener {
		/**
		 * Notifies the receiver that the random move button has been clicked.
		 */
		void onRandomMove();

		/**
		 * Notifies the receiver that the AI move button has been clicked.
		 */
		void onAiMove();

		/**
		 * Notifies the receiver that a color change has been requested by the
		 * user.
		 * 
		 * @param pieceId
		 *            the piece whose color is to be changed.
		 * @param color
		 *            the new color of the piece.
		 */
		void onColorChange(String pieceId, Color color);

		/**
		 * Notifies the receiver that a player mode change has been requested by
		 * the user
		 * 
		 * @param mode
		 *            the new player mode. It may only have valid values, to be
		 *            converted to a {@link SwingView#PlayerMode}.
		 * @param pieceId
		 *            the piece whose mode is to be changed.
		 */
		void onModeChange(String mode, String pieceId);

		/**
		 * Notifies the receiver that the quit button has been clicked.
		 */
		void onQuit();

		/**
		 * Notifies the receiver that the restart button has been clicked.
		 */
		void onRestart();
	}

	private SettingsListener listener;
	private JScrollPane statusMessagesScrollPanel;
	private CustomJTable playerInfoTable;
	private JPanel automaticMovesPanel;
	private JPanel pieceColorsPanel;
	private JPanel quitPanel;
	private JDialog colorDialog;

	/**
	 * Constructs a new settings panel with all the necessary info.
	 * 
	 * @param playerIds
	 *            Array of String(s) containing the playerIds' Ids.
	 * @param isAiBanned
	 *            whether there is an ai player.
	 * @param isRandBanned
	 *            wether there is a random player.
	 * @param owner
	 *            set to null if Single Window, contains the window's owner Id
	 *            if Multi Window.
	 */
	public SettingsPanel(String[] playerIds, Boolean isAiBanned,
			Boolean isRandBanned, String owner) {
		this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		buildStatusMessagesScrollPanel();
		buildPlayerInformationPanel(playerIds, owner);
		buildPieceColorsPanel(playerIds);
		buildPlayerModesPanel(playerIds, isAiBanned, isRandBanned, owner);
		buildAutomaticMovesPanel(isAiBanned, isRandBanned);
		buildQuitPanel(owner);
	}

	/**
	 * The listener which receives all the events generated by the subpanels.
	 * 
	 * @param listener
	 *            the new listener.
	 */
	public void setSettingsListener(SettingsListener listener) {
		this.listener = listener;
	}

	/**
	 * Builds the StatusMessagesScrollPanel and it(s) component(s).
	 */
	private void buildStatusMessagesScrollPanel() {
		statusMessagesScrollPanel = new JScrollPane();

		this.add(statusMessagesScrollPanel);
		statusMessagesScrollPanel.setBorder(defaultBorder("Status messages"));
		statusMessagesScrollPanel.setPreferredSize(new Dimension(200, 100));

		JTextArea statusMessagesTxt = new JTextArea();
		statusMessagesTxt.setEditable(false);

		DefaultCaret caret = (DefaultCaret) statusMessagesTxt.getCaret();
		caret.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);
		statusMessagesScrollPanel.setViewportView(statusMessagesTxt);
		// Source:
		// http://stackoverflow.com/questions/2483572/making-a-jscrollpane-automatically-scroll-all-the-way-down
	}

	/**
	 * Builds the playerInformationPanel depending on the Window Mode.
	 * 
	 * @param playerIds
	 *            the string containing the piece(s) Id(s).
	 * @param owner
	 *            set to null if Single Window, contains the owner if
	 *            MultiWindow.
	 */
	private void buildPlayerInformationPanel(String[] playerIds, String owner) {

		JPanel playerInformationPanel = new JPanel();
		playerInformationPanel.setLayout(new BorderLayout());

		playerInformationPanel.setBorder(defaultBorder("Player information"));

		playerInfoTable = new CustomJTable();

		Object[][] tableContent = new Object[playerIds.length][3];

		buildPlayerInfoTable(tableContent, playerIds, owner);


		playerInfoTable.setRowColors(new Color[playerIds.length]);

		playerInformationPanel.setPreferredSize(new Dimension(200, 100));
		playerInformationPanel.setLayout(new BorderLayout());
		JScrollPane tableContainer = new JScrollPane(playerInfoTable);
		playerInformationPanel.add(tableContainer, BorderLayout.CENTER);
		this.add(playerInformationPanel);
	}

	/**
	 * Builds the content for the playerInfoTable to display.
	 * 
	 * @param tableContent
	 *            the content of the table.
	 * @param playerIds
	 *            the ids of the players to be shown.
	 * @param owner
	 *            the player who owns this window. More information will be
	 *            shown for the owner. {@code null} if the window is in single
	 *            view mode.
	 */
	private void buildPlayerInfoTable(Object[][] tableContent,
			String[] playerIds, String owner) {
		if (owner == null) {

			int i = 0;
			for (String player : playerIds) {
				tableContent[i][0] = player;
				tableContent[i][1] = "Manual";
				tableContent[i][2] = "";
				i++;
			}
		} else {
			int i = 0;
			for (String player : playerIds) {
				tableContent[i][0] = player;
				if (player.equals(owner)) {
					tableContent[i][1] = "Manual";
					tableContent[i][2] = "";
				}
				i++;
			}
		}
		playerInfoTable.setModel(new DefaultTableModel(tableContent,
				new String[] { "Player", "Mode", "# Pieces" }));
		setPlayerInfoRenderer();

		playerInfoTable.setAutoCreateRowSorter(false);
	}

	/**
	 * Sets the renderer for the playerInfoTable
	 */
	private void setPlayerInfoRenderer() {
		playerInfoTable.getColumnModel().getColumn(0)
				.setCellRenderer(new CustomRenderer());
		playerInfoTable.getColumnModel().getColumn(1)
				.setCellRenderer(new CustomRenderer());
		playerInfoTable.getColumnModel().getColumn(2)
				.setCellRenderer(new CustomRenderer());
		playerInfoTable.getTableHeader().setReorderingAllowed(false);
		playerInfoTable.getTableHeader().setResizingAllowed(false);
	}

	/**
	 * Given a group layout builds it for the playerInformationPanel
	 * 
	 * @param playerInformationLayout
	 *            the layout to be configured.
	 */
	private void buildGroupLayout(GroupLayout playerInformationLayout) {
		playerInformationLayout.setHorizontalGroup(playerInformationLayout
				.createParallelGroup(Alignment.LEADING).addGroup(
						playerInformationLayout
								.createSequentialGroup()
								.addGap(5)
								.addComponent(playerInfoTable,
										GroupLayout.PREFERRED_SIZE,
										GroupLayout.DEFAULT_SIZE,
										GroupLayout.PREFERRED_SIZE)));
		playerInformationLayout.setVerticalGroup(playerInformationLayout
				.createParallelGroup(Alignment.LEADING).addGroup(
						playerInformationLayout
								.createSequentialGroup()
								.addGap(5)
								.addComponent(playerInfoTable,
										GroupLayout.PREFERRED_SIZE,
										GroupLayout.DEFAULT_SIZE,
										GroupLayout.PREFERRED_SIZE)));
	}

	/**
	 * Builds the pieceColorsPanel where the player can change everyone's colors
	 * in his/her window playerIds String containing the Id(s) for the player
	 * playerIds.
	 * 
	 * @param playerIds
	 *            the string containing the piece(s) Id(s).
	 */
	private void buildPieceColorsPanel(String[] playerIds) {
		pieceColorsPanel = new JPanel();
		pieceColorsPanel.setBorder(defaultBorder("Piece colors"));
		this.add(pieceColorsPanel);
		FlowLayout fl_pieceColorsPanel = new FlowLayout(FlowLayout.LEFT, 5, 5);
		pieceColorsPanel.setLayout(fl_pieceColorsPanel);

		final JComboBox<String> playerComboBox = new JComboBox<String>();
		setPlayerComboBox(playerIds, playerComboBox);

		final JButton selectColorButton = new JButton("Select color");
		selectColorButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (selectColorButton.isEnabled()) {
					buildColorsDialog((String) playerComboBox.getSelectedItem());
				}
			}
		});
		pieceColorsPanel.add(playerComboBox);
		pieceColorsPanel.add(selectColorButton);
	}

	/**
	 * Builds the panel with the player modes
	 * 
	 * @param playerIds
	 *            the ids of the players.
	 * @param isAiBanned
	 *            whether there is an ai player.
	 * @param isRandBanned
	 *            wether there is a random player.
	 * @param owner
	 *            the player who owns this window. More information will be
	 *            shown for the owner. {@code null} if the window is in single
	 *            view mode.
	 */
	private void buildPlayerModesPanel(String[] playerIds, Boolean isAiBanned,
			Boolean isRandBanned, String owner) {
		JPanel playerModesPanel = new JPanel();
		playerModesPanel.setBorder(defaultBorder("Player modes"));
		this.add(playerModesPanel);
		playerModesPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 5, 5));

		final JComboBox<String> playerComboBoxModes = new JComboBox<>();
		if (owner == null) {
			setPlayerComboBox(playerIds, playerComboBoxModes);

		} else {
			String auxArray[] = new String[1];
			auxArray[0] = owner;
			setPlayerComboBox(auxArray, playerComboBoxModes);
		}
		playerModesPanel.add(playerComboBoxModes);

		ArrayList<String> auxPlayerModes = new ArrayList<>();// it's easier to
																// expand
		auxPlayerModes.add(PlayerMode.MANUAL.toString());
		if (!isAiBanned) {
			auxPlayerModes.add(PlayerMode.AI.toString());
		}
		if (!isRandBanned) {
			auxPlayerModes.add(PlayerMode.RANDOM.toString());
		}
		buildPlayerComboBox(playerModesPanel, auxPlayerModes,
				playerComboBoxModes);

	}

	/**
	 * Builds the components of the player modes panel and adds them to it.
	 * 
	 * @param playerModesPanel
	 *            the panel to be built.
	 * @param auxPlayerModes
	 *            the current player modes.
	 * @param playerComboBoxModes
	 *            the combo box for the modes.
	 */
	private void buildPlayerComboBox(JPanel playerModesPanel,
			ArrayList<String> auxPlayerModes,
			final JComboBox<String> playerComboBoxModes) {
		String auxArray[] = new String[auxPlayerModes.size()];
		auxArray = auxPlayerModes.toArray(auxArray);
		final JComboBox<String> modesComboBox = new JComboBox<String>();
		modesComboBox.setModel(new DefaultComboBoxModel<String>(auxArray));
		playerModesPanel.add(modesComboBox);

		final JButton setButton = new JButton("Set");
		setButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (setButton.isEnabled()) {
					listener.onModeChange(
							(String) modesComboBox.getSelectedItem(),
							(String) playerComboBoxModes.getSelectedItem());
				}
			}
		});
		playerModesPanel.add(setButton);
	}

	/**
	 * Builds the automatic moves Panel which contains two buttons for one-time
	 * computer based moves.
	 * 
	 * @param isAiBanned
	 *            whether there is an ai player.
	 * @param isRandBanned
	 *            whether there is a random player.
	 */
	private void buildAutomaticMovesPanel(Boolean isAiBanned,
			Boolean isRandBanned) {
		if (!isAiBanned || !isRandBanned) {
			automaticMovesPanel = new JPanel();
			automaticMovesPanel.setBorder(defaultBorder("Automatic moves"));
			this.add(automaticMovesPanel);
			automaticMovesPanel.setLayout(new FlowLayout(FlowLayout.CENTER, 5,
					5));

			if (!isAiBanned) {
				addIntelligentButton();
			}

			if (!isRandBanned) {
				addRandomButton();
			}
		}
	}

	/**
	 * Adds the one-time move IntelligentButton to the automaticMovesPanel,
	 * which will generate an intelligentMove.
	 */
	private void addIntelligentButton() {
		final JButton btnIntelligent = new JButton("Intelligent");
		btnIntelligent.setPreferredSize(new Dimension(90, 23));
		btnIntelligent.setMaximumSize(new Dimension(90, 23));
		btnIntelligent.setMinimumSize(new Dimension(90, 23));
		btnIntelligent.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (btnIntelligent.isEnabled())
					listener.onAiMove();
			}
		});

		automaticMovesPanel.add(btnIntelligent);
	}

	/**
	 * Adds the one-time move RandomButton to the automaticMovesPanel, which
	 * will generate a random move.
	 */
	private void addRandomButton() {
		final JButton btnRandom = new JButton("Random");
		btnRandom.setPreferredSize(new Dimension(90, 23));
		btnRandom.setMaximumSize(new Dimension(90, 23));
		btnRandom.setMinimumSize(new Dimension(90, 23));
		btnRandom.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (btnRandom.isEnabled()) {
					listener.onRandomMove();
				}
			}
		});

		automaticMovesPanel.add(btnRandom);
	}

	/**
	 * Builds the quit Panel according to GameMode.
	 * 
	 * @param owner
	 *            null if single window, Id of the window owner otherwise.
	 */
	private void buildQuitPanel(String owner) {
		quitPanel = new JPanel();
		this.add(quitPanel);
		quitPanel.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
		final JButton btnQuit = new JButton("Quit");
		btnQuit.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				if (btnQuit.isEnabled()) {
					listener.onQuit();
				}
			}
		});
		quitPanel.add(btnQuit);

		if (owner == null) {
			final JButton btnRestart = new JButton("Restart");
			btnRestart.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent arg0) {
					if (btnRestart.isEnabled()) {
						listener.onRestart();
					}
				}
			});
			quitPanel.add(btnRestart);
		}
	}

	/**
	 * Builds a dialog which contains a color chooser.
	 * 
	 * @param pieceId
	 *            the id of the piece whose color we are changing. It will be
	 *            passed to the listener.
	 */
	private void buildColorsDialog(final String pieceId) {
		colorDialog = new JDialog();
		colorDialog.setVisible(true);
		colorDialog.setModal(true);
		colorDialog.dispatchEvent(new WindowEvent(colorDialog,
				WindowEvent.WINDOW_CLOSING));
		final ColorPanel colorPanel = new ColorPanel();
		colorPanel.setOpaque(true);
		colorDialog.setContentPane(colorPanel);

		final JButton chooseButton = new JButton("Choose");
		chooseButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				if (chooseButton.isEnabled()) {
					Color c = colorPanel.getColorChooser().getColor();
					colorDialog.setVisible(false);
					colorDialog.dispose();
					if (c != null) {
						listener.onColorChange(pieceId, c);
					}
				}
			}
		});
		colorPanel.add(chooseButton, BorderLayout.SOUTH);
		colorDialog.pack();
		colorDialog.setVisible(true);
	}

	/*
	 * Adds a new line to the scrollPanel.
	 */
	public void addLineToStatus(String news) {
		((JTextArea) statusMessagesScrollPanel.getViewport().getView())
				.append(news + "\n");
	}

	/**
	 * Gets the player row.
	 * 
	 * @param playerId
	 *            the id of the player whose row is asked for.
	 * @return the player's row index.
	 */
	public int getPlayerRow(String playerId) {
		int playerRow = 0;
		for (playerRow = 0; playerRow < playerInfoTable.getRowCount(); playerRow++) {
			if (playerId.equals(playerInfoTable.getValueAt(playerRow, 0).toString())) {
				return playerRow;
			}
		}
		return -1;
	}

	/**
	 * Updates the score of a player.
	 * 
	 * @param playerRow
	 *            the index of the row for that player.
	 * @param addScore
	 *            the Score to be added to the player.
	 */
	public void updatePlayerScore(int playerRow, int addScore) {
		playerInfoTable.setValueAt(addScore, playerRow, 2);
	}

	/**
	 * Updates the game mode of a player in the table.
	 * 
	 * @param playerRow
	 *            the index of the row for that player.
	 * @param playerMode
	 *            the Mode set for the player.
	 */
	public void updatePlayerMode(int playerRow, String playerMode) {
		playerInfoTable.setValueAt(playerMode, playerRow, 1);
	}

	/**
	 * Updates the color of a player in the table.
	 * 
	 * @param playerRow
	 *            the index of the row for that player.
	 * @param color
	 *            the new Color for the player.
	 */
	public void updatePlayerColor(int playerRow, Color color) {
		playerInfoTable.setRowColor(playerRow, color);
		playerInfoTable.updateUI();
	}

	/**
	 * Configures a combo box to select players.
	 * 
	 * @param players
	 *            the array of String(s) containing the player(s) Id(s).
	 * @param playerComboBox
	 *            the combo box to be configured.
	 */
	private void setPlayerComboBox(String[] players,
			JComboBox<String> playerComboBox) {
		playerComboBox.setModel(new DefaultComboBoxModel<String>(players));
	}

	/**
	 * Sets the panels enabled(isEnabled) or not enabled (!isEnabled).
	 * 
	 * @param isEnabled
	 *            whether it should be enabled or disabled.
	 */
	public void setPanelsEnabled(Boolean isEnabled) {
		setEnabled(automaticMovesPanel, isEnabled);
		setEnabled(quitPanel, isEnabled);
	}

	/**
	 * Sets only the AutoMovesPanel enabled(isEnabled) or not enabled.
	 * (!isEnabled)
	 * 
	 * @param isEnabled
	 *            whether it should be enabled or disabled.
	 */
	public void setAutoMovesEnabled(Boolean isEnabled) {
		setEnabled(automaticMovesPanel, isEnabled);
	}

	/**
	 * Sets only the QuitPanelEnabled enabled (isEnabled) or not enabled.
	 * (!isEnabled)
	 * 
	 * @param isEnabled
	 *            whether it should be enabled or disabled.
	 */
	public void setQuitPanelEnabled(Boolean isEnabled) {
		setEnabled(quitPanel, isEnabled);
	}

	/**
	 * Recursively sets to enabled (isEnabled) or not enabled (!isEnabled) all
	 * the components in a given Container.
	 * 
	 * @param component
	 *            the component whose enabled state will be set.
	 * @param isEnabled
	 *            whether it should be enabled or disabled.
	 */
	public void setEnabled(Component component, boolean isEnabled) {
		component.setEnabled(isEnabled);
		if (component instanceof Container) {
			for (Component contained : ((Container) component).getComponents()) {
				contained.setEnabled(isEnabled);
			}
		}
	}

	/**
	 * Creates the border to be used by all subpanels: a line border with the
	 * given title.
	 * 
	 * @param title
	 *            that will be set for the new border.
	 * @return the new border.
	 */
	private TitledBorder defaultBorder(String title) {
		return new TitledBorder(new LineBorder(new Color(153, 180, 209)),
				title, TitledBorder.LEADING, TitledBorder.TOP, null, new Color(
						0, 0, 0));
	}
}
